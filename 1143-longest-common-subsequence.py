import time
import functools
from typing import List, Optional

class Solution:
    """Determine the longest common subsequence for two strings - the longest common sequence that can be generated by deleting letters from each string"""

    #   runtime: beats 77%
    def longestCommonSubsequence_DP_BottomUp_Subsequent(self, text1: str, text2: str) -> int:

        #   table[i][j]: length of longest sequence between text1[:i+1] and text2[:j+1]
        table = [ [ 0 for _ in range(len(text2)) ] for _ in range(len(text1)) ]

        #   table[i][j] =
        #       table[i-1][j-1] + 1                 if text1[i] == text2[j]
        #       max(table[i-1][j], table[i][j-1])   otherwise
        for i in range(0, len(text1)):
            for j in range(0, len(text2)):
                if text1[i] == text2[j]:
                    if i-1 >= 0 and j-1 >= 0:
                        table[i][j] = table[i-1][j-1] + 1
                    else:
                        table[i][j] = 1
                else:
                    table[i][j] = max(table[i-1][j], table[i][j-1])

        return table[len(text1)-1][len(text2)-1]


    #   runtime: beats 24%
    def longestCommonSubsequence_DP_TopDown_Subsequent(self, text1: str, text2: str) -> int:

        #   adapted from BottomUp (see above)
        @functools.cache
        def solve(i, j):
            if text1[i] == text2[j]:
                if i-1 >= 0 and j-1 >= 0:
                    return solve(i-1, j-1) + 1
                else:
                    return 1
            else:
                temp1 = solve(i-1, j) if i-1 >= 0 else 0
                temp2 = solve(i, j-1) if j-1 >= 0 else 0
                return max(temp1, temp2)

        return solve(len(text1)-1, len(text2)-1)


    def longestCommonSubsequence_DP_BottomUp_Previous(self, text1: str, text2: str) -> int:
        #   table[i][j]: longest common subsequence of 'text1[i:]' and 'text2[j:]'
        table = [ [ 0 for col in range(len(text2)+1) ] for row in range(len(text1)+1) ]

        for col in range(len(text2)-1, -1, -1):
            for row in range(len(text1)-1, -1, -1):

                #   Case 1: Letters match
                if text1[row] == text2[col]:
                    table[row][col] = 1 + table[row+1][col+1]

                #   Case 2: Letters do not match
                else:
                    table[row][col] = max(table[row+1][col], table[row][col+1])

        return table[0][0]


    def longestCommonSubsequence_DP_TopDown_Previous(self, text1: str, text2: str) -> int:
        memo = dict()

        def solve(p1: int, p2: int) -> int:
            if (p1, p2) in memo:
                return memo[(p1, p2)]

            #   base case, empty string -> can't match any more characters
            if p1 == len(text1) or p2 == len(text2):
                memo[(p1,p2)] = 0
                return 0

            #   Case 1: Letters match
            if text1[p1] == text2[p2]:
                result = 1 + solve(p1+1, p2+1)
                memo[(p1, p2)] = result
                return result

            #   Case 2: Letters do not match
            else:
                result = max(solve(p1+1, p2), solve(p1, p2+1))
                memo[(p1, p2)] = result
                return result

        return solve(0, 0)


    def longestCommonSubsequence_DP_BottomUp_SpaceOptimised(self, text1: str, text2: str) -> int:
        raise NotImplementedError("complete `longestCommonSubsequence_DP_BottomUp_Iterative_SpaceOptimised`")


s = Solution()
test_functions = [ s.longestCommonSubsequence_DP_BottomUp_Subsequent, s.longestCommonSubsequence_DP_TopDown_Subsequent, s.longestCommonSubsequence_DP_BottomUp_Previous, s.longestCommonSubsequence_DP_TopDown_Previous, s.longestCommonSubsequence_DP_BottomUp_SpaceOptimised, ]

inputs = [ ("abcde","ace"), ("abc","abc"), ("abc","def"), ("bl","yby"), ("ylqpejqbalahwr","yrkzavgdmdgtqpg"), ]
checks = [ 3, 3, 0, 1, 3, ]
assert len(inputs) == len(checks), "input/check lists length mismatch"
assert len(inputs) > 0, "No input"

for f in test_functions:
    print(f.__name__)
    start_time = time.time()
    for (text1, text2), check in zip(inputs, checks):
        print(f"text1=({text1}), text2=({text2})")
        result = f(text1, text2)
        print(f"result=({result})")
        assert result == check, "Check comparison failed"
    print("elapsed_us=(%0.2f)" % ((time.time() - start_time) * 1_000_000))
    print()

